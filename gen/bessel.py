# Copyright Dan Price. All rights reserved.

from scipy import special as sp
from scipy.optimize import fsolve
from heapq import merge
import numpy as np
from numpy import float32 as f32
from numpy import float64 as f64

d = sp.jn_zeros(0, 1)[0]
dfactor = 1/d
broken = [231, 244, 281, 288, 347, 348, 357, 405, 406, 419, 437, 505, 506, 507, 570, 582, 591, 643, 644, 655, 658, 679, 706, 713, 722, 752, 756, 757, 764, 775, 840]

def get_copyright_notice():
    return '// Copyright Dan Price. All rights reserved.\n\n'

def get_gen_notice():
    contents = "//////////////////////////////////\n"
    contents += "////  GENERATED BY bessel.py  ////\n"
    contents += "////  DO NOT EDIT MANUALLY!!  ////\n"
    contents += "//////////////////////////////////\n\n"
    return contents

def bessel_harmonics(max_order=832, num_zeros=270, max_freq_factor=850.0, specific=False, log=False):
    def dolog(n):
        print("Calculating Bessel Function of the First Kind of order " + str(n))
    def noop(n):
        pass
    logfun = dolog if log else noop
    f = []
    num = max_order if specific else 0
    for n in range(num, max_order + 1):
        if n in broken:
            print("Scipy inexplicably hangs on the Bessel Function of the First Kind of order " + str(n) + "; skipping")
            continue
        logfun(n)
        j = [z/d for z in filter(lambda e: e < max_freq_factor, sp.jn_zeros(n, num_zeros))]
        num_zeros = len(j)
        f = list(merge(f, j))
    return f

def gen_bessel_cpp_old(filename="Bessel.gen.cpp"):
    num_zeros = 270
    contents = ""

    contents += "//////////////////////////////////\n"
    contents += "////  GENERATED BY bessel.py  ////\n"
    contents += "////  DO NOT EDIT MANUALLY!!  ////\n"
    contents += "//////////////////////////////////\n\n"

    contents += "#include \"bessel.h\"\n\nnamespace AlbumBot\n{\n"

    contents += "\tconst float bessel_harmonics_by_order[833][270] = {\n"
    arrcomma = ""
    for n in range(833):
        contents += "\t\t" + arrcomma + "{ "
        if arrcomma == "":
            arrcomma = ", "
        if n in broken:
            contents += "0.0f"
            for i in range(269):
                if i % 16 == 15:
                    contents += "\n\t\t\t"
                contents += ", 0.0f"
        else:
            j = bessel_harmonics(n, num_zeros, specific=True)
            num_zeros = len(j)
            comma = ""
            for i in range(num_zeros):
                if i % 16 == 15:
                    contents += "\n\t\t\t"
                contents += comma + str(f32(j[i])) + "f"
                if comma == "":
                    comma = ", "
            for i in range(270 - num_zeros):
                if (num_zeros + i) % 16 == 15:
                    contents += "\n\t\t\t"
                contents += comma + "0.0f"
        contents += " }\n"
    contents += "\t};\n\n"

    j = bessel_harmonics()
    num_harmonics = len(j)
    contents += "\tconst size_t NUM_BESSEL_HARMONICS = " + str(num_harmonics) + ";\n\n"

    contents += "\tconst float bessel_harmonics[] = {\n"
    comma = ""
    for i in range(len(j)):
        if i % 16 == 15:
            contents += "\n\t\t"
        contents += comma + str(f32(j[i])) + "f"
        if comma == "":
            comma = ", "
    contents += "\n\t};\n\n"

    contents += "\tstatic_assert(sizeof(bessel_harmonics) == sizeof(float) * " + str(num_harmonics) + ", \"Error in bessel.py::gen_bessel_cpp(): NUM_BESSEL_HARMONICS doesn't match length of bessel_harmonics\");\n"

    contents += "}\n\n"

    with open(filename, 'w') as f:
        f.write(contents)

def get_jn_norm_cubic_xy(n_order, n_zero):
    var_ndarray = [0.0] if n_zero == 1 else sp.jn_zeros(n_order, n_zero - 1)
    x0 = var_ndarray[len(var_ndarray) - 1]*dfactor
    var_ndarray = sp.jn_zeros(n_order, n_zero)
    x3 = var_ndarray[len(var_ndarray) - 1]*dfactor
    x1 = x0 + 1/3*(x3 - x0)
    x2 = x1 + x1 - x0
    y0 = 1.0 if n_zero == 1 and n_order == 0 else 0.0
    y1 = sp.jn(n_order, d*x1)
    y2 = sp.jn(n_order, d*x2)
    x0_2 = x0*x0
    x1_2 = x1*x1
    x2_2 = x2*x2
    x3_2 = x3*x3
    a = np.array([[x0_2*x0, x0_2, x0, 1.0],
                  [x1_2*x1, x1_2, x1, 1.0],
                  [x2_2*x2, x2_2, x2, 1.0],
                  [x3_2*x3, x3_2, x3, 1.0]])
    b = np.array([y0, y1, y2, 0.0])
    return np.linalg.solve(a, b), (x0, x1, x2, x3), (y0, y1, y2, 0.0)

def get_jn_norm_cubic(n_order, n_zero):
    c, x, y = get_jn_norm_cubic_xy(n_order, n_zero)
    return c

def get_jn_norm_cubic_uneven_xy(n_order, n_zero):
    if n_zero == 1 and n_order > 1:
        var_ndarray = sp.jn_zeros(n_order, n_zero)
        x3 = var_ndarray[-1]
        x1 = 0.0
        x2 = 0.0
        x1_2 = 0.0
        y1 = 0.0
        c_split = None
        split_point = None
        further_split_point = None

        # Find the zeros of the third derivative of Jn
        def jnd3(x):
            return sp.jvp(n_order, x, 3)
        x1 = fsolve(jnd3, x3 - (6 if n_order > 2 else 3), factor=0.1, maxfev=1000)
        x1 = x1[0]
        x2 = fsolve(jnd3, x1 + 0.5*(x3 - x1), factor=0.1, maxfev=1000)
        x2 = x2[0]

        # Find the zero of the fourth derivative Jn closest to halfway between the two zeros of the
        # third derivative of Jn found previously
        def jnd4(x):
            return sp.jvp(n_order, x, 4)
        x15 = fsolve(jnd4, x1 + 0.5*(x2 - x1), factor=0.1, maxfev=1000)
        x15 = x15[0]
        y15 = sp.jn(n_order, x15)
        x15 = x15*dfactor
        x15_2 = x15*x15

        # Find a second cubic to handle 0 <= x < x1
        x0 = fsolve(lambda x: sp.jn(n_order, x) - 0.001, 0.9*x1 - 2.8, factor=0.1, maxfev=1000)
        #print ('n = ' + str(n_order) + ', x1 = ' + str(x1) + ', x0 = ' + str(x0))
        x0 = x0[0]
        y0 = sp.jn(n_order, x0)
        x0 = x0*dfactor
        x0_2 = x0*x0
        y1 = sp.jn(n_order, x1)
        #xx1 = x1/2
        #xx1 = x1/6
        #xx2 = 2/3*x1
        xx1 = x0 + (x1 - x0)/6
        xx2 = x0 + 2/3*(x1 - x0)
        yy1 = sp.jn(n_order, xx1)
        yy2 = sp.jn(n_order, xx2)
        xx1 = xx1*dfactor
        xx2 = xx2*dfactor
        x1 = x1*dfactor
        xx1_2 = xx1*xx1
        xx2_2 = xx2*xx2
        x1_2 = x1*x1
        #a = np.array([np.array([0.0, 0.0, 0.0, 1.0]),
        a = np.array([np.array([x0_2*x0, x0_2, x0, 1.0]),
                      #np.array([0.0, 0.0, 1.0, 0.0]), # first derivative at 0 equals 0
                      np.array([xx1_2*xx1, xx1_2, xx1, 1.0]),
                      np.array([xx2_2*xx2, xx2_2, xx2, 1.0]),
                      np.array([x1_2*x1, x1_2, x1, 1.0])])
        #b = np.array([0.0, 0.0, yy1, y1])
        #b = np.array([0.0, yy1, yy2, y1])
        b = np.array([y0, yy1, yy2, y1])
        #print('solving ' + str(a) + ' and ' + str(b))
        c_split = np.linalg.solve(a, b)
        split_point = x1
        further_split_point = x0

        #x0 = 0.0
        #x0_2 = 0.0
        #y0 = 0.0
        y2 = sp.jn(n_order, x2)
        x2 = x2*dfactor
        x3 = x3*dfactor
        x2_2 = x2*x2
        x3_2 = x3*x3
        #a = np.array([np.array([x0_2*x0, x0_2, x0, 1.0]),
        a = np.array([np.array([x1_2*x1, x1_2, x1, 1.0]),
                      np.array([x15_2*x15, x15_2, x15, 1.0]),
                      np.array([x2_2*x2, x2_2, x2, 1.0]),
                      np.array([x3_2*x3, x3_2, x3, 1.0])])
        b = np.array([y1, y15, y2, 0.0])
        return np.linalg.solve(a, b), (x1, x15, x2, x3), (y1, y15, y2, 0.0), c_split, split_point, further_split_point
    c, x, y = get_jn_norm_cubic_xy(n_order, n_zero)
    return c, x, y, None, None, None

def get_jn_norm_cubic_uneven(n_order, n_zero):
    c, x, y, c_split, split_point, further_split_point = get_jn_norm_cubic_uneven_xy(n_order, n_zero)
    return c, c_split, split_point, further_split_point

def genbessig():
    print('def gen_bessel_cpp(filename="Bessel.gen.cpp", headerfilename="Bessel.gen.h", n_orders=32, n_zeros=24):')

def gen_bessel_cpp(filename="Bessel.gen.cpp", headerfilename="Bessel.gen.h", n_orders=32, n_zeros=24):
    if headerfilename != '' and filename != '':
        contents = get_copyright_notice()
        contents += get_gen_notice()
        contents += "#pragma once\n\n"
        contents += "#include <cstddef>\n\n"
        contents += "namespace AlbumBot\n"
        contents += "{\n"
        contents += "\tconstexpr const size_t NUM_BESSEL_ORDERS = " + str(n_orders) + ";\n"
        contents += "\tconstexpr const size_t NUM_POSITIVE_BESSEL_ZEROS_PER_ORDER = " + str(n_zeros) + ";\n"
        contents += "\textern const float bessel_harmonics_by_order[NUM_BESSEL_ORDERS][NUM_POSITIVE_BESSEL_ZEROS_PER_ORDER];\n"
        contents += "\textern const float bessel_harmonics[];\n"
        contents += "\textern const size_t NUM_BESSEL_HARMONICS;\n"
        contents += "\t// Fast approximation of Bessel functions of the first kind,\n"
        contents += "\t// with first positive zero normalized to 1\n"
        contents += "\tfloat fast_jn_norm(const size_t n, const float x);\n"
        contents += "}\n\n"

        with open(headerfilename, 'w') as f:
            f.write(contents)

        num_zeros = n_zeros
        contents = get_copyright_notice()
        contents += get_gen_notice()

        contents += f"#include \"{headerfilename}\"\n#include \"Cubic.h\"\n"
        contents += "#include <array>\n#include <cstdint>\n#include <cmath>\n\n"
        contents += "namespace AlbumBot\n{\n"

        contents += "\tconst float bessel_harmonics_by_order[NUM_BESSEL_ORDERS][NUM_POSITIVE_BESSEL_ZEROS_PER_ORDER] = {\n"
        cubics = "\tnamespace\n\t{\n\t\tstd::array<std::array<Cubic, NUM_POSITIVE_BESSEL_ZEROS_PER_ORDER>, "
        cubics += "NUM_BESSEL_ORDERS> cubics_by_order = {\n"
        #leadzeros = "\tnamespace\n\t{\n\t\tstd::array<float, NUM_BESSEL_ORDERS> lead_zeros = {\n"
        split_cubics = "\tnamespace\n\t{\n\t\tstd::array<std::array<Cubic, 2>, NUM_BESSEL_ORDERS> split_cubics = {\n"
        split_points = "\tnamespace\n\t{\n\t\tconst float split_points[NUM_BESSEL_ORDERS] = {\n"
        further_split_points = "\tnamespace\n\t{\n\t\tconst float further_split_points[NUM_BESSEL_ORDERS] = {\n"
        two_order_inv = "\tnamespace\n\t{\n\t\tconst float two_order_inv[NUM_BESSEL_ORDERS] = {\n"
        arrcomma = ""
        nullcubic = "Cubic(0.0f, 0.0f, 0.0f, 0.0f)"
        for n in range(n_orders):
            contents += "\t\t" + arrcomma + "{ "
            cubics += "\t\t\t" + arrcomma + "std::array<Cubic, NUM_POSITIVE_BESSEL_ZEROS_PER_ORDER>{ "
            #leadzeros += "\t\t\t" + arrcomma
            split_cubics += "\t\t\t" + arrcomma
            split_points += "\t\t\t" + arrcomma
            further_split_points += "\t\t\t" + arrcomma
            two_order_inv += "\t\t\t" + arrcomma + str(f32(1.0 / float(int(n) << 1) if n > 0 else 1.0)) + "f"
            if arrcomma == "":
                arrcomma = ", "
            if n in broken:
                contents += "0.0f"
                cubics += nullcubic
                #leadzeros += "0.0f"
                split_cubics += "std::array<Cubic, 2>{ " + nullcubic + ", " + nullcubic + " }"
                split_points += "0.0f"
                further_split_points += "0.0f"
                for i in range(n_zeros - 1):
                    if i % 16 == 15:
                        contents += "\n\t\t\t"
                        cubics += "\n\t\t\t\t"
                    contents += ", 0.0f"
                    cubics += ", " + nullcubic

            else:
                #leadzeros += str(f32(sp.jn_zeros(n, 1)[0])) + "f"
                j = bessel_harmonics(n, num_zeros, specific=True)
                num_zeros = len(j)
                comma = ""
                added_split = False
                for i in range(num_zeros):
                    if i % 16 == 15:
                        contents += "\n\t\t\t"
                        cubics += "\n\t\t\t\t"
                    contents += comma + str(f32(j[i])) + "f"
                    c, c_split, split_point, further_split_point = get_jn_norm_cubic_uneven(n, i + 1)
                    if c_split is not None:
                        split_cubics += ("std::array<Cubic, 2>{\n\t\t\t\tCubic(" +
                                         str(f32(c_split[0])) + "f, " + str(f32(c_split[1])) + "f, " +
                                         str(f32(c_split[2])) + "f, " + str(f32(c_split[3])) + "f),\n" +
                                         "\t\t\t\tCubic(" + str(f32(0.001 / (further_split_point**3))) +
                                         "f, 0.0f, 0.0f, 0.0f)\n\t\t\t}")
                        split_points += str(f32(split_point)) + "f"
                        further_split_points += str(f32(further_split_point)) + "f"
                        added_split = True
                    cubic = "Cubic(" + (str(f32(c[0])) + "f, " + str(f32(c[1])) + "f, " +
                                        str(f32(c[2])) + "f, " + str(f32(c[3])) + "f)")
                    cubics += comma + cubic
                    if comma == "":
                        comma = ", "
                if not added_split:
                    split_cubics += "std::array<Cubic, 2>{ " + nullcubic + ", " + nullcubic + " }"
                    split_points += "0.0f"
                    further_split_points += "0.0f"
                for i in range(n_zeros - num_zeros):
                    if (num_zeros + i) % 16 == 15:
                        contents += "\n\t\t\t"
                        cubics += "\n\t\t\t\t"
                    contents += comma + "0.0f"
                    cubics += comma + nullcubic
            contents += " }\n"
            cubics += " }\n"
            #leadzeros += "\n"
            split_cubics += "\n"
            split_points += "\n"
            further_split_points += "\n"
            two_order_inv += "\n"
        contents += "\t};\n\n"
        cubics += "\t\t};\n\t}\n\n"
        #leadzeros += "\t\t};\n\t}\n\n"
        split_cubics += "\t\t};\n\t}\n\n"
        split_points += "\t\t};\n\t}\n\n"
        further_split_points += "\t\t};\n\t}\n\n"
        two_order_inv += "\t\t};\n\t}\n\n"

        j = bessel_harmonics(n_orders - 1, n_zeros)
        num_harmonics = len(j)
        contents += "\tconst size_t NUM_BESSEL_HARMONICS = " + str(num_harmonics) + ";\n\n"

        contents += "\tconst float bessel_harmonics[] = {\n"
        comma = ""
        for i in range(len(j)):
            if i % 16 == 15:
                contents += "\n\t\t"
            contents += comma + str(f32(j[i])) + "f"
            if comma == "":
                comma = ", "
        contents += "\n\t};\n\n"

        contents += "\tstatic_assert(sizeof(bessel_harmonics) == sizeof(float) * " + str(num_harmonics) + ", \"Error in bessel.py::gen_bessel_cpp(): NUM_BESSEL_HARMONICS doesn't match length of bessel_harmonics\");\n\n"

        contents += cubics
        #contents += leadzeros
        contents += split_cubics
        contents += split_points
        contents += further_split_points
        contents += two_order_inv

        contents += "\tfloat fast_jn_norm(const size_t n, const float x)\n"
        contents += "\t{\n"
        contents += "\t\tif (n >= NUM_BESSEL_ORDERS)\n\t\t\treturn 0.0f;\n"

        contents += "\t\tif (x < split_points[n])\n"
        contents += "\t\t{\n"
        contents += "\t\t\treturn split_cubics[n][x < further_split_points[n]](x);\n"
        #contents += "\t\t\tconst float amps[2] = { split_cubics[n](x), 0.0f };\n"
        #contents += "\t\t\treturn amps[amps[0] < 0.001f]; // Silence if below -60 dB\n"
        contents += "\t\t}\n"

        # Linear search may be faster than binary in optimized builds
        #contents += "\t\tconst float (&h)[NUM_POSITIVE_BESSEL_ZEROS_PER_ORDER] = bessel_harmonics_by_order[n];\n"
        #contents += "\t\t// Linear search bessel_harmonics_by_order[n] for x\n"
        #contents += "\t\tsize_t lo(0);\n"
        #contents += "\t\tsize_t hi(1);\n"
        #contents += "\t\twhile (hi <= NUM_POSITIVE_BESSEL_ZEROS_PER_ORDER && x >= h[hi - 1])\n"
        ##contents += "\t\twhile (hi <= NUM_POSITIVE_BESSEL_ZEROS_PER_ORDER && x >= bessel_harmonics_by_order[n][hi - 1])\n" # Slower
        #contents += "\t\t{\n"
        #contents += "\t\t\tlo = hi++;\n"
        #contents += "\t\t}\n"

        # Binary search
        #contents += "\t\tconst float (&h)[NUM_POSITIVE_BESSEL_ZEROS_PER_ORDER] = bessel_harmonics_by_order[n];\n"
        #contents += "\t\t// Binary search bessel_harmonics_by_order[n] for x\n"
        #contents += "\t\tauto get_zero = [&h](const size_t m)\n"
        #contents += "\t\t{\n"
        #contents += "\t\t\tconst size_t idx(!m);\n"
        #contents += "\t\t\tconst size_t hidx[2]{ m - 1, 0 };\n"
        #contents += "\t\t\tconst float result[2]{ h[hidx[idx]], 0.0f };\n"
        #contents += "\t\t\treturn result[idx];\n"
        #contents += "\t\t};\n"
        #contents += "\t\tconstexpr const size_t MAX_ZERO_IDX = " + str(n_zeros - 1) + ";\n"
        #contents += "\t\tsize_t lo(0);\n"
        #contents += "\t\tsize_t hi(MAX_ZERO_IDX);\n"
        #contents += "\t\twhile (lo <= hi)\n"
        #contents += "\t\t{\n"
        #contents += "\t\t\tconst size_t test(lo + ((hi - lo) >> 1));\n"
        #contents += "\t\t\tif (x < get_zero(test))\n"
        #contents += "\t\t\t{\n"
        #contents += "\t\t\t\thi = test - 1;\n"
        #contents += "\t\t\t}\n"
        #contents += "\t\t\telse if (x >= get_zero(test + 1))\n"
        #contents += "\t\t\t{\n"
        #contents += "\t\t\t\tlo = test + 1;\n"
        #contents += "\t\t\t}\n"
        #contents += "\t\t\telse\n"
        #contents += "\t\t\t{\n"
        #contents += "\t\t\t\tlo = test;\n"
        #contents += "\t\t\t\tbreak;\n"
        #contents += "\t\t\t}\n"
        #contents += "\t\t}\n"

        # Math search is fastest
        # Works up to order 31
        # Quadratic arch to apex: y=(b0-b1)((x-a1)/(a0-a1))^2+b1
        contents += "\t\t// Find via math; works up to order 31\n"
        contents += "\t\tconst float (&h)[NUM_POSITIVE_BESSEL_ZEROS_PER_ORDER] = bessel_harmonics_by_order[n];\n"
        contents += "\t\tauto get_zero = [&h](const size_t m)\n"
        contents += "\t\t{\n"
        contents += "\t\t\tconst size_t idx(!m);\n"
        contents += "\t\t\tconst size_t hidx[2]{ m - 1, 0 };\n"
        contents += "\t\t\tconst float result[2]{ h[hidx[idx]], 0.0f };\n"
        contents += "\t\t\treturn result[idx];\n"
        contents += "\t\t};\n"
        contents += "\t\tconstexpr const float z01 = " + str(f32(d)) + "f;\n"
        contents += "\t\tconstexpr const float z01overpi = static_cast<float>(" + str(f64(d)) + " / 3.1415926535897932384626433832795);\n"
        contents += "\t\tconstexpr const float adj[2] = { 0.0f, 0.1f * z01 };\n"
        contents += "\t\tconstexpr const float overdiv = 1.0f / 20.0f;\n"
        contents += "\t\tconst float hn1(bessel_harmonics_by_order[n][0]);\n"
        contents += "\t\tconst float p((x - hn1));\n"
        contents += "\t\tconst float adj2[2] = { static_cast<float>(n > 11 && x > hn1), overdiv * p * (2.0f - p * two_order_inv[n]) };\n"
        contents += "\t\tconst float intermediates[2] = { std::floorf(z01overpi * (x - hn1 + adj[static_cast<size_t>(n == 0)]) - adj2[static_cast<size_t>(n > 11 && x > hn1 && x < hn1 + (n << 1))]) + 1.0f, 0.0f };\n"
        contents += "\t\tconst size_t initial = intermediates[static_cast<size_t>(intermediates[0] < 0.0f)];\n"
        contents += "\t\tconst size_t lo = initial - static_cast<size_t>((get_zero(initial)) > x);\n"

        contents += "\t\tif (lo >= NUM_POSITIVE_BESSEL_ZEROS_PER_ORDER)\n\t\t\treturn 0.0f;\n"
        contents += "\t\treturn cubics_by_order[n][lo](x);\n"

        #contents += "\t\t// If x is between origin and first zero and result is negative, return 0,\n"
        #contents += "\t\t// implemented with horrendous bit twiddling hacks and well defined type punning, blech.\n"
        #contents += "\t\t// Compared to straightforward branching, this slightly increases speed in debug.\n"
        #contents += "\t\tconst float result[2]{ cubics_by_order[n][lo](x), 0.0f };\n"
        #contents += "\t\tuint32_t resultbits;\n"
        #contents += "\t\tconst char* const reader(reinterpret_cast<const char*>(&result[0]));\n"
        #contents += "\t\tchar* const writer(reinterpret_cast<char*>(&resultbits));\n"
        #contents += "\t\twriter[0] = reader[0];\n"
        #contents += "\t\twriter[1] = reader[1];\n"
        #contents += "\t\twriter[2] = reader[2];\n"
        #contents += "\t\twriter[3] = reader[3];\n"
        #contents += "\t\treturn result[((size_t)!lo) & ((size_t)!!(resultbits & 0x80000000ul))];\n"

        contents += "\t}\n"
        contents += "}\n\n"

        with open(filename, 'w') as f:
            f.write(contents)

if __name__ == '__main__':
    import sys
    if '-gen' in sys.argv:
        gen_bessel_cpp()

