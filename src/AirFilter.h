// Copyright Dan Price. All rights reserved.

/////////////////////////////////
//// DO NOT EDIT MANUALLY!!! ////
//// GENERATED BY airfilt.py ////
/////////////////////////////////

#pragma once

#include <complex>
#include <cmath>

namespace json2wav::airfilt
{
	// Biquad lopass filter section for 200ms of sound propagation
	namespace lp200ms
	{
		constexpr const double b0 = 0.013820248887970746;
		constexpr const double b1 = 0.11056199110376597;
		constexpr const double b2 = 0.22112398220753193;
		constexpr const double a1 = -0.9065802782691826;
		constexpr const double a2 = 0.25208650046845127;
	}

	// Biquad hishelf filter section for 200ms of sound propagation
	namespace hs200ms
	{
		constexpr const double b0 = 0.977669728360092;
		constexpr const double b1 = -1.8797635286974297;
		constexpr const double b2 = 0.903554298374364;
		constexpr const double a1 = -1.9235658557457735;
		constexpr const double a2 = 0.9250263537827995;
	}

	template<size_t nfreqs>
	inline double flerp(
		const double x,
		const double (&freqs)[nfreqs],
		const double (&vals)[nfreqs],
		const double (&slopes)[nfreqs])
	{
		size_t idx = 0;
		for (; idx < nfreqs; ++idx)
			if (x < freqs[idx])
				break;
		if (idx == 0)
			return vals[0];
		if (idx == nfreqs)
			--idx; // Extend lerp from final two points
		return slopes[idx]*(x - freqs[idx]) + vals[idx];
	}

	constexpr const double warped_freqs[] = {
		500.0,
		1001.2939453125,
		2013.3544921875002,
		3052.33154296875,
		4123.6083984375,
		5248.71826171875,
		6944.4580078125,
		8656.34765625,
		10890.41748046875,
		13011.43798828125,
		16009.936523437498,
		18992.28515625
	};

	constexpr const double unwarp_factors[] = {
		1.0,
		0.9987077268183259,
		0.9933670437872117,
		0.9828552232180351,
		0.9700242150820294,
		0.9526135240420954,
		0.9359981718785706,
		0.9241772994438239,
		0.9182384438369184,
		0.9222654721797697,
		0.9369181431819534,
		0.947753250960248
	};

	constexpr const double unwarp_slopes[] = {
		0.0,
		-2.57787510453282e-06,
		-5.277039054239265e-06,
		-1.011747137366738e-05,
		-1.197730359850939e-05,
		-1.5474658616144164e-05,
		-9.798291395716476e-06,
		-6.905160297882538e-06,
		-2.658312440607017e-06,
		1.898627725671799e-06,
		4.886669388157687e-06,
		3.6330788624388657e-06
	};

	constexpr const double freqs[] = {
		500,
		1000,
		2000,
		3000,
		4000,
		5000,
		6500,
		8000,
		10000,
		12000,
		15000,
		18000
	};

	constexpr const double zeroes[] = {
		-4,
		-4,
		-4,
		-4,
		-4,
		-4,
		-3.5,
		-3.1,
		-2.7,
		-2.4,
		-2.1,
		-1.9
	};

	constexpr const double zeroes_slopes[] = {
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0,
		0.0003333333333333333,
		0.0002666666666666666,
		0.00019999999999999996,
		0.00015000000000000012,
		9.999999999999994e-05,
		6.666666666666672e-05
	};

	inline double fprewarp(const double fc44100)
	{
		return flerp(fc44100, warped_freqs, unwarp_factors, unwarp_slopes);
	}

	inline double f2z(const double fc_prewarped)
	{
		return flerp(fc_prewarped, freqs, zeroes, zeroes_slopes);
	}

	struct biquad
	{
		double b0;
		double b1;
		double b2;
		double a1;
		double a2;
	};

	inline biquad get_bessel2_lpf(const double fc, const unsigned long sr = 44100)
	{
		static constexpr const double tau = 6.283185307179586;
		static constexpr const double dt44100 = 1.0/44100.0;
		static constexpr const double bessel2_3db_factor = 1.3616541287161306;
		static constexpr const double w0_factor = tau*dt44100/bessel2_3db_factor;

		biquad filt;

		const double fc44100 = (sr == 44100) ? fc : fc*44100.0/double(sr);
		const double fc_prewarped = fprewarp(fc44100)*fc44100;
		const double z_inf = f2z(fc_prewarped);
		const double w0 = w0_factor*fc_prewarped;
		const std::complex<double> eiw0 = std::polar(1.0, w0);
		const double _2cosw0 = 2.0*eiw0.real();
		const double _3sinw0 = 3.0*eiw0.imag();
		const double oa0 = 1.0/(4.0 - _2cosw0 + _3sinw0);
		filt.a1 = (4.0 - 8.0*eiw0.real())*oa0;
		filt.a2 = (4.0 - _2cosw0 - _3sinw0)*oa0;
		const double _1mzinf = 1.0 - z_inf;
		filt.b0 = 12.0*(1.0 - eiw0.real())/(_1mzinf*_1mzinf)*oa0;
		const double zinfb0 = z_inf*filt.b0;
		filt.b1 = -2.0*zinfb0;
		filt.b2 = z_inf*zinfb0;
		return filt;
	}

	inline double time2freq(const double time)
	{
		const double log2t = std::log2(time);
		return std::exp2(((-0.006047191747695711*log2t + -0.05652338821183782)*log2t + -0.7165375051705365)*log2t + 10.675836540666259);
	}

	inline biquad get_airfilt(const double time, const unsigned long sr = 44100)
	{
		return get_bessel2_lpf(time2freq(time), sr);
	}
}

